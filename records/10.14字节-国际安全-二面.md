# 后端开发-字节
## 设计一个关注的功能
### 1.数据建模
 User 表：存储用户基本信息。

 Follow 表：存储用户之间的关注关系。每条记录表示一个用户关注另一个用户。

- follower_id (关注者的用户ID)

- followee_id (被关注者的用户ID)

- create_time (关注的时间)

索引： 在 Follow 表上建立索引，优化常见查询，比如查询一个用户的粉丝、关注列表等。

冗余字段：为了提高性能，可以将粉丝数和关注数冗余存储在 User 表中，这样避免了每次都进行查询和统计。

### 2.关注和取消功能
关注操作：

- 用户点击“关注”按钮时，后端会检查该用户是否已经关注目标用户，如果没有，则在 Follow 表中插入一条记录。

- 需要保证一个用户只能关注另一个用户一次。可以在 Follow 表上增加一个唯一约束，确保 (follower_id, followee_id) 组合唯一。

取消关注：

- 用户点击“取消关注”按钮时，系统会从 Follow 表中删除相应的记录。

- 如果用户想要取消所有的关注，可以通过批量删除操作来实现。

### 3. 粉丝数和关注数
实时更新：每当有用户关注或取消关注时，除了 Follow 表的操作，还需要更新关注者和被关注者的粉丝数、关注数。

- 关注数：在用户的 User 表中更新其关注数。

- 粉丝数：每次有新的关注关系建立时，更新被关注者的粉丝数。

这两项操作可以通过数据库触发器（trigger）或者在应用层进行控制。

#### 事务机制
为了避免使用触发器，可以在应用层进行控制，把操作放在同一个事务中，确保发生错误时回滚。

#### 异步更新
关注和粉丝数的更新可以采用异步处理方式（比如使用消息队列），确保前端请求不被阻塞。

在操作成功后，通过异步任务处理粉丝和关注数的更新，保证系统的响应速度。

### 4. 查看关注和粉丝列表
- 查看某个用户的粉丝： 查询 Follow 表中所有 followee_id 为该用户ID的记录，然后返回这些 follower_id 用户的基本信息。

- 查看某个用户的关注： 查询 Follow 表中所有 follower_id 为该用户ID的记录，返回 followee_id 用户的基本信息。

- 分页处理：由于粉丝和关注数可能会非常庞大，所以需要加上分页查询（比如使用 LIMIT 和 OFFSET，或者基于游标的分页方式）。

### 5.优化策略
缓存： 由于查看粉丝或关注列表的操作可能频繁且数据量大，可以考虑使用缓存（如 Redis）存储每个用户的粉丝和关注列表。

- 用户关注或取消关注时，可以异步更新缓存。

- 当获取粉丝或关注列表时，首先从缓存中查找，如果缓存中没有，再从数据库中查询。

异步处理： 如果关注操作涉及到多次数据更新，可以将这些操作放入消息队列（如 RabbitMQ），进行异步处理，避免操作阻塞。

### 6.特殊设计

- 互相关注：有些社交平台允许用户通过互相关注建立更加亲密的关系。这时候，除了关注和粉丝外，还需要设计一个新的关系表（比如 MutualFollow）来存储互相关注的数据。

- 屏蔽/拉黑：用户可以选择屏蔽或者拉黑其他用户，屏蔽后即使是关注关系，用户也看不到对方的内容。可以通过在 Follow 表中加入 status 字段来管理关注状态，status 可以是“正常”、“屏蔽”等。

- 推荐关注：通过算法推荐用户感兴趣的人或内容，可以在后台根据用户行为分析进行推荐。

### 7.API设计

关注操作：

- POST /users/{user_id}/follow: 关注某个用户

- DELETE /users/{u ser_id}/unfollow: 取消关注某个用户

获取粉丝和关注列表：

- GET /users/{user_id}/followers: 获取某个用户的粉丝列表

- GET /users/{user_id}/following: 获取某个用户的关注列表

## 原语
### 1. 如何实现原语的原子性
在指令之前插入关中断指令，指令后插入开中断指令，从而在指令执行期间屏蔽掉中断信号

### 2. 进程控制相关的原语
#### 进程创建
创建原语：申请空白PCB，为新进程分配所需的资源，初始化PCB，将PCB插入就绪队列

引起进程创建的事件：用户登录，作业调度，提供服务，应用请求。

#### 进程的终止
撤销原语： 从PCB集合中找到终止进程的PCB，若进程正在运行，立即剥夺CPU，将CPU分配给其他进程，终止其所有子进程，将该进程拥有的所有资源归还给父进程或操作系统，删除PCB