## 后端开发 - 美团
1、项目中为什么要用Caffeine、Redis 混合的二级缓存框架。

在项目中使用二级缓存是为了兼顾 性能 和 一致性。单一使用 Redis 有网络开销，单一使用 Caffeine 又会导致分布式节点间数据不一致。因此我基于模板方法模式设计了一个二级缓存框架：一级缓存用 Caffeine 提供本地热点数据的极致性能，二级缓存用 Redis 保证分布式一致性，并结合 MQ 广播消息来刷新各节点本地缓存。这样既提升了访问速度，又降低了数据库和 Redis 压力，系统性能从 238 QPS 提升到 824 QPS。具体来说，对于字典类/基础数据，计算中间结果，降级信息，这些数据量适中，且查询非常高频，我们选择放到了本地缓存中

2、项目中提到封装注解式加锁的底层原理，引出jkd，cglib的应用场景，限制和特点、Redisson的原理

3、不使用看门狗机制，如何处理业务还没执行完，锁被释放的问题。

1) LUA+CAS释放锁

2) 拆分业务逻辑，细分逻辑加锁解锁

4、RabbitMQ的核心思想和模块，消息的轮转

核心模块，exchange, queue, binding

5、自定义线程池有哪些参数，在实际中如何设置这些参数

6、SettableFuture是什么知道吗，介绍一下

7、为什么在实习中，需要用到装饰器模式，为什么不用适配器模式

8、抽象工厂模式和工厂模式分别是什么有什么区别

9、RPC的全称是什么，核心思想和流程

10、DTS的基础思想和原理

11、手撕：实现策略模式+lc 143 重排链表

## 后端实习生 - 字节跳动

* 布隆过滤器的实现原理是什么？它有哪些弊端？是否存在误判？如何解决这些误判问题？

* 当在浏览器中输入URL并回车后，到页面展示出来，整个过程发生了什么？

* 假设有一千张车票，从北京到上海，中间有很多经停站，如何设计车票数据表的字段，并查询具体库存？

* 请讲讲分布式锁的实现方案，以及如何用Redis实现分布式锁？

* 请解释数据库中MVCC(多版本并发控制)的概念、原理及其实现方式。

* 请解释TCP的三次握手和四次挥手过程。

* 请举例说明单例模式在前端开发中的应用场景和实现方式。

* 请详细介绍一下你在Node端服务中负责的模块和具体实现。

* 在使用Redis进行库存扣减时，如何保证Redis和MySQL之间的数据一致性？

* 在MySQL的可重复读隔离级别下，是如何通过技术手段解决幻读问题的？

* 在Redis中如何高效删除大key

* HTTP和HTTPS有什么区别？

* HTTP和HTTPS有什么区别？HTTPS是如何保证通信安全的？

* MySQL中的并发事务问题有哪些？幻读是什么？如何解决幻读问题？

## 后端开发 快手
* 分布式锁是如何实现的？如何进行锁的续期？

* 分布式锁是怎么实现的，为什么要加上线程标识，不加lua脚本哪种情况下会出现锁误删？

* 你认为自己在前端开发方面有哪些优势？

* 请解释分布式锁中的"看门狗"机制的原理和作用。

* 请解释数据库中快照读和当前读的概念以及它们之间的区别。

* 请解释数据库中MVCC(多版本并发控制)的概念、原理及其实现方式。

* 请解释MySQL索引的最左匹配原则及其应用场景。

* 请解释Redis分布式锁中的看门狗机制是如何工作的？

* 请说明数据库事务的四种隔离级别及其各自的特点。

* 请谈谈你在实习中的主要收获

* 请详细解释RedLock算法的基本原理和实现机制。

* 请详细解释RocketMQ中延迟消息的实现机制。

* 请详细介绍一下你做过的项目，包括项目背景、你的角色、技术难点和解决方案。

* 请详细说明数据库的四种隔离级别（读未提交、读已提交、可重复读、串行化）的特点以及它们之间的区别。

* 请详细说明BIO、NIO和AIO三种IO模型的区别以及各自的适用场景。

* 什么是幻读？它是如何产生的，有哪些解决方法？

* 什么是ABA问题？有哪些常见的解决方法？

* 数据库索引的作用是什么？有哪些常见的索引类型？

* 在高并发支付场景下，如何根据具体需求选择适合的并发控制机制（乐观锁、悲观锁、MVCC）？

* 在你的实习经历或个人项目中，遇到过哪些具有挑战性的事情？你是如何解决的？

* 在你的项目中使用了哪些组件？

* 在你的项目中为什么选择设计双表结构？这种设计有什么优势和考虑？

* 在使用分布式锁的过程中可能会遇到哪些问题？如何解决这些问题？

* 在数据库事务中，怎样解决幻读问题？

* Spring中的事务管理（注解式和编程式）是如何保证原子性的？Spring事务的底层实现原理是什么？事务失败后如何进行恢复？

* 请详细说明分布式锁的实现原理和常见实现方式。

* 请解释乐观锁和悲观锁的概念、实现方式及适用场景。

### 后端开发-得物
1、详细介绍查询接口的性能提升情况

“我们系统需要给不同商户推荐不同产品，每个产品有多套展示配置，计算量很大，比如 6 个产品 × 36 套配置。顺序计算接口响应慢，大约 1500ms。为了解决这个问题，我做了两方面优化：一是用 Redis 缓存规则，避免频繁访问数据库，并提供开关支持紧急修改；二是用 CompletableFuture + 自定义线程池将每个产品的规则计算异步并行执行。经过优化后，接口响应从 1500ms 降到 400ms，性能提升了接近 4 倍，同时保持规则的动态可控性。”

2、优惠券的数据模型

答：回答时可以按 ids(三个id)，types(优惠券type，业务type)，优惠券自身信息（发放时间，锁定状态，使用时间等），还有持券人的信息

3、券信息和流水信息是否耦合

答：我们目前的模型是耦合设计，把券的基本信息、发放信息、持有人信息和使用流水放在同一份文档里，这样能减少查询成本、支撑高 QPS。但它的代价是扩展性差，如果未来需要支持多次使用或更复杂的流水审计，我们会考虑将 usage_log 单独拆表，做成解耦设计。

4、接口的QPS？

答：平时在100-200之间，在大促期间会到500-800之间

5、为什么要用装饰器模式

答：最底层是基础服务，负责核心推荐功能；在基础服务上，通过装饰器动态叠加增强功能，例如主位副位判断、素材变量替换等。装饰器链可以灵活组合，不同商户或产品的定制逻辑通过链上的不同装饰器实现，无需修改基础类。为了统一创建不同链的实例，我们用工厂模式管理代理类和装饰器链的生成。

6、CompletableFuture和普通的Future有什么区别

Future 只能表示异步任务结果，get() 会阻塞，而且组合多个任务麻烦；而 CompletableFuture 支持非阻塞回调、链式组合和异步异常处理，更适合复杂异步场景，比如同时计算多产品多配置规则的推荐逻辑
“我们没有用普通的 Future，主要有三个原因：

1️⃣ 阻塞问题：普通 Future 调用 get() 会阻塞线程，处理大量规则时容易导致线程占用过多，响应慢；而 CompletableFuture 支持非阻塞回调，可以在任务完成后自动处理结果，不影响主线程。

2️⃣ 任务组合能力：我们的规则计算涉及多个产品、多套配置，需要同时并行计算并汇总结果。Future 很难方便地组合多个任务，而 CompletableFuture 提供链式组合和 allOf / anyOf 聚合方法，方便管理多个异步任务。

3️⃣ 异常和灵活性：CompletableFuture 支持链式异常处理和自定义线程池，保证异步任务稳定执行，也方便扩展新的规则逻辑，而普通 Future 异常只能在阻塞时捕获，灵活性较差。

所以在高并发和复杂异步场景下，CompletableFuture 更适合我们业务需求。”

7、为什么要用MQ
1️⃣ 直接监听 Binlog 的问题

直接消费 Binlog：应用直接解析数据库变更日志（例如通过 Canal）

问题：

耦合强：业务服务直接依赖数据库 Binlog，数据库压力大或变动会影响业务。

可靠性差：一旦消费失败或服务宕机，可能丢失数据，需要额外实现补偿机制。

扩展性差：多个业务服务都需要监听同一 Binlog，难以横向扩展。

高并发处理复杂：直接消费 Binlog 时，顺序、事务和并发控制都需要自己处理。

2️⃣ 使用 MQ 的优势

解耦：生产者（DTS 或 Binlog 推送服务）与消费者（业务处理服务）解耦，服务可以独立扩展和部署。

可靠性：MQ 支持消息持久化、重试机制和消费确认，保证消息不丢失。

高并发和异步：MQ 能够平滑处理高 QPS，消费者可按业务类型并行消费。

灵活路由：不同业务可以注册不同消费者，按策略模式处理消息，实现多业务共存。

可扩展性：新业务或新功能只需增加新的消费者，不影响原有流程。

我们不直接监听 Binlog，而是通过 MQ 同步增量数据。原因是：直接消费 Binlog 会耦合业务和数据库，处理高并发和异常补偿复杂。而 MQ 提供可靠的消息持久化、异步消费和多业务分发能力，既保证了数据可靠性，也方便我们按业务类型灵活扩展和处理

8、如何设计发券系统

发券
1）触发条件”用户注册、下单、参与活动或运营后台手动发放。

2）策略判断：判断用户是否符合条件（等级、历史消费、活动次数等）。判断券是否还有剩余库存。

3）券生成/领取：系统生成或从已有券池中分配一张券给用户。写入 UserCoupon 表，记录用户ID、券ID、发放时间、状态（未使用）。

4）缓存与消息：更新券库存缓存（如 Redis）。发送消息到 MQ，通知用户或其他系统更新状态。

5）发放完成：用户收到券，可在个人中心查看。

核销：

1）用户使用券：用户在下单/支付时选择使用优惠券。

2）券验证

检查券状态：否未使用

是否在有效期内：是否满足使用条件（如最低消费），可通过 Redis 缓存快速校验。

3）核销操作：扣减券库存（原子操作）更新 UserCoupon.status = 已使用，记录 used_time 和 order_id

4）事务保证：核销与订单支付保持事务一致性，防止重复核销或丢失券。

5）异步统计：核销完成后，异步更新券使用统计信息和报表。

9、Spring Nacos和Zookeeper的区别
Nacos 是“注册中心 + 配置中心一体化”，Zookeeper 更偏向分布式协调工具。

10、Spring启动流程

Spring 启动大致分为 加载、创建容器、注册 Bean、初始化、完成 五大阶段

初始化 SpringApplication：读取主类、加载环境配置（application.yml/properties）、确定运行模式（普通应用或 Web 应用），并准备 SpringApplication 对象。

创建 ApplicationContext：根据应用类型创建相应的容器（如 AnnotationConfigApplicationContext 或 AnnotationConfigServletWebServerApplicationContext），并注册核心 Bean，如环境变量、事件广播器和消息源。

扫描和注册 Bean：扫描 @Configuration、@Component、@Service、@Repository、@Controller 等注解类，将 BeanDefinition 注册到容器，同时解析依赖注入相关注解（@Autowired、@Value）。

Bean 实例化与初始化：按照依赖关系实例化 Bean，执行 Aware 接口方法（如 ApplicationContextAware）、初始化回调（@PostConstruct、afterPropertiesSet()），并执行 BeanPostProcessor 的前后处理方法。

刷新容器与事件发布：刷新容器完成单例 Bean 初始化，并发布相关事件（如 ContextRefreshedEvent、ApplicationReadyEvent）通知应用已准备就绪。

WebServer 启动与回调执行（Spring Boot）：如果是 Web 应用，启动内置 WebServer（Tomcat/Jetty/Undertow），注册 DispatcherServlet，并执行 CommandLineRunner 或 ApplicationRunner 等启动回调。

11、Spring IOC

Spring IOC（控制反转）是 Spring 框架提供的一种设计思想和容器机制，它通过容器来创建对象、管理对象的生命周期和注入对象之间的依赖，从而实现了对象之间的解耦。Spring IOC 的核心是 BeanFactory 或 ApplicationContext，它通过 BeanDefinition 和依赖注入（DI）机制，将对象依赖交给容器管理，而不是让对象自己去创建和管理依赖。