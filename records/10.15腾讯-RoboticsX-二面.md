## 后端开发-腾讯
### 1. 手撕1：合并K个升序链表
#### 顺序法

##### 算法描述：
最朴素的方法：用一个变量 ans 来维护以及合并的链表，第 i 次循环把第 i 个链表和 ans 合并，答案保存到 ans 中。

##### 复杂度分析：
时间复杂度：假设每个链表的最长长度是 n。在第一次合并后，ans 的长度为 n；第二次合并后，ans 的长度为$2×n$，第 i 次合并后，ans 的长度为 i×n。第 i 次合并的时间代价是 $O(n+(i−1)×n)=O(i×n)$，那么总的时间代价为$ O(\sum_{i=1}^{k}(i×n))=O( \frac{(1+k)⋅k}{2}×n)=O(k^{2}n)$，故渐进时间复杂度为$O(k^{2}n)$。

#### 分治合并
##### 算法描述：
考虑优化方法一，用分治的方法进行合并。

- 将 k 个链表配对并将同一对中的链表合并；
- 第一轮合并以后，k 个链表被合并成了 2k 个链表，平均长度为 $\frac{n}{2}$，然后是 $4k$ 个链表，$8k$ 个链表等等；
- 重复这一过程，直到我们得到了最终的有序链表。

##### 复杂度分析：
考虑递归「向上回升」的过程——

- 第一轮合并 $2k$ 组链表，每一组的时间代价是 $O(2n)$；
- 第二轮合并 $4k$ 组链表，每一组的时间代价是 $O(4n)$；
  
......所以总的时间代价是 $O\left(\sum_{i=1}^{\infty} \frac{2^i}{k} \times 2^i n\right) = O(kn \times \log k)$。

故渐进时间复杂度为 $O(kn \times \log k)$。

递归会使用到 $O(\log k)$ 空间代价的栈空间。

#### 优先队列
``` java
class Solution {
    class Status implements Comparable<Status>{
        int val;
        ListNode ptr;
        
        public Status(int val, ListNode ptr){
            this.val = val;
            this.ptr = ptr;
        }

        public int compareTo(Status status2){
            return this.val - status2.val;
        }

    }

    PriorityQueue<Status> queue = new PriorityQueue<Status>();

    public ListNode mergeKLists(ListNode[] lists){
        for(ListNode node : lists){
            if(node!=null){
                queue.offer(new Status(node.val, node));
            }
        }
        ListNode head = new ListNode(0);
        ListNode tail = head;

        while(!queue.isEmpty()){
            Status f = queue.poll();
            tail.next = f.ptr;
            tail = tail.next;
            if(f.ptr.next != null){
                queue.offer(new Status(f.ptr.next.val, f.ptr.next));
            }
        }
        return head.next;
    }
}
```
时间复杂度：考虑优先队列中的元素不超过 k 个，那么插入和删除的时间代价为 O(logk)，这里最多有 kn 个点，对于每个点都被插入删除各一次，故总的时间代价即渐进时间复杂度为 O(kn×logk)。
空间复杂度：这里用了优先队列，优先队列中的元素不超过 k 个，故渐进空间复杂度为 O(k)。


### 2. 手撕2：数组中第K个最大元素
#### 基于快速排序的选择方法
##### 算法描述：
由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l⋯q−1] 和 a[q+1⋯r] 是否是有序的，我们不关心
##### 时间复杂度分析：
时间复杂度：O(n)，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。
空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为 O(logn)。

#### 基于堆排序的选择方法
##### 算法描述：
我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k−1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。
##### 时间复杂度分析
时间复杂度：O(nlogn)，建堆的时间代价是 O(n)，删除的总代价是 O(klogn)，因为 k<n，故渐进时间复杂为 O(n+klogn)=O(nlogn)。
空间复杂度：O(logn)，即递归使用栈空间的空间代价。

### 3. MySQL查询时，具体有哪些操作，哪些操作最耗时
MySQL查询的操作：
查询解析  &rarr; 查询优化  &rarr; 执行计划生成  &rarr; 数据读取 &rarr; 连接操作  &rarr; 排序操作  &rarr; 聚合操作 &rarr; 临时表的使用  &rarr; 锁机制  &rarr; 网络传输

其中，比较耗时的是数据读取操作，如果一个数据不在缓存中，MySQL需要从磁盘中读取数据，这会导致较慢的查询响应时间。同时，如果没有命中索引，也可能触发全表扫描，导致大量的IO操作

在临时表的使用中，如果临时表的数据量比较大，无法放入内存中，则会写入硬盘中，显著增加查询时间，临时表的创建，存储，销毁都会比较耗时

GPT模拟出来的MySQL查询执行时间表格
| 操作步骤                                  | 描述                                                  | 假设耗时（毫秒）  | 备注                                   |
| ------------------------------------- | --------------------------------------------------- | --------- | ------------------------------------ |
| **查询解析（Parsing）**                     | SQL 语法解析、检查是否有语法错误                                  | 1-10 ms   | 对于简单查询通常很快，但复杂查询可能稍慢                 |
| **查询优化（Optimization）**                | 优化器选择最佳的执行计划                                        | 1-20 ms   | 大查询可能需要更多时间来选择最佳计划，尤其是没有合适索引时        |
| **执行计划生成（Execution Plan Generation）** | 根据优化器的选择生成执行计划（例如选择索引、连接顺序）                         | 5-50 ms   | 如果查询涉及复杂的 JOIN 或子查询，可能会更长            |
| **数据读取（Data Retrieval）**              | 从磁盘或缓存读取数据，依赖于是否使用缓存、表的大小和索引的效率                     | 10-200 ms | 如果缓存命中，通常较快；没有索引或大表则可能导致较慢的磁盘 I/O 读取 |
| **连接操作（Join）**                        | 多表连接，涉及的表越多，数据量越大，连接操作越复杂，所需时间越长                    | 50-500 ms | 外连接通常比内连接耗时，特别是没有索引时需要全表扫描           |
| **排序操作（Sorting）**                     | 对查询结果进行排序（例如 `ORDER BY`）                            | 20-500 ms | 如果数据量大并且没有索引，排序会涉及大量的内存或磁盘操作         |
| **聚合操作（Aggregation）**                 | 执行 `GROUP BY`、`COUNT`、`SUM` 等聚合操作                   | 50-500 ms | 聚合操作需要扫描大量数据，特别是没有索引时会增加查询时间         |
| **临时表使用（Temporary Tables）**           | 对于复杂查询（如 `GROUP BY`、`DISTINCT`、`ORDER BY`），可能会创建临时表 | 50-500 ms | 如果临时表无法完全放入内存，会写入磁盘，导致更长的延迟          |
| **锁机制（Locking）**                      | 查询过程中可能会加锁，尤其是在事务处理中或多个查询并发时                        | 10-200 ms | 锁竞争时可能导致查询阻塞，特别是在高并发环境中              |
| **网络传输（Network Latency）**             | 查询结果从数据库传输到客户端                                      | 5-100 ms  | 如果查询结果集非常大，网络传输会成为瓶颈                 |


### 4. MySQL的单表上限是2kw，这个是怎么算出来的
对于B+树索引来说，假设：
- 非叶子节点内指向其他页的数量为 x
- 叶子节点内能容纳的数据行数为 y
- B+ 数的层数为 z

那么$Total = x^{(z-1)} * y$,也就是说总数会等于 x 的 z-1 次方 与 Y 的乘积。

对于每一个页面来说，可以存放数据的大小是15kb
#### 关于x的取值
主键假设是Bigint(8byte)，页号也是固定的（4byte），那么索引页中一条数据就是12byte，所以x = 15*1024/12≈1280 行。

#### 关于y的取值
按照每一行数据1kb来算，可以放15条，公式中按B+树为3层，算出来的total就是24576000 （约 2.45kw）。

对于数据量的增多，不能够将索引全部加载到内存当中，就会导致磁盘的IO，从而降低查询性能。

### 5.优惠券系统，如何保证可靠性
redis+一致性比对+修复队列

### 6. Kafka如何保证EXACTLY ONCE
1. ACK
2. 维护ProducerId + parition &rarr; LastSequenceNumber之间的映射关系
3. 事务机制（维护分区Exactly once）

### 7.进程，线程和协程，以及通信方式
1. 进程(Process)

- 进程 是操作系统分配资源的基本单位，它包含了程序代码、数据、系统资源等，执行中的程序实例。在多核 CPU 上，多个进程可能同时运行。

- 每个进程通常有 自己的地址空间，并且有 独立的资源（如内存、文件描述符、句柄等）。多个进程之间相互隔离。

- 操作系统通过 进程调度 来管理多个进程在 CPU 核心 上的执行。

#### PCB
进程控制块（PCB，Process Control Block） 是操作系统用来管理进程的一个数据结构，它包含了一个进程在执行期间所需的所有信息。操作系统通过 PCB 来跟踪进程的状态、资源分配、CPU 上下文等信息，并在上下文切换时保存和恢复进程的状态。

``` PCB结构信息
PCB{
    PID: 12345                          // 进程标识符
    State: Running                      // 进程状态（如 Running、Ready、Blocked）
    Program Counter: 0x40012345         // 程序计数器（指向下一条要执行的指令）
    CPU Registers: {...}                // CPU 寄存器的当前值
    Memory Management: {...}            // 内存管理信息，如页表、段表
    Priority: 10                        // 进程的优先级
    Open Files: [file1, file2, ...]     // 进程打开的文件
    I/O Resources: [dev1, dev2]         // 进程占用的 I/O 资源
    Parent PID: 6789                    // 父进程 PID
    Child PIDs: [23456, 34567]          // 子进程 PID
    Signal Handlers: {...}              // 进程的信号处理函数
    Time Slice: 50                      // 时间片
}

```
操作系统把进程切换到运行状态，意味着进程占用CPU在执行，当OS切换到其他状态，则不能在CPU中运行，会选择下一个要运行的进程，为什么说线程是调度的基本单位，是因为调度的是进程中的主线程。

2. 线程（Thread）
