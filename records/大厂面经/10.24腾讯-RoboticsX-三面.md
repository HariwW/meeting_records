## 后端开发-腾讯
### 1. 宽表建设需求中，为什么不用分库分表，而采用了ES
我们的性能瓶颈主要在“复杂查询 + 模糊检索 + 多条件组合”，

1. 分库分表适合的场景不同

- 多维度查询（组合条件）；

- 模糊查询；

- 运营侧需要灵活检索；

- 索引维护困难、命中率低。

即使分库分表，SQL 依然会被拆成多次查询 + 汇总聚合，反而更复杂，查询性能未必提升。

2. 分库分表不适合模糊搜索和多条件过滤

分库分表后要支持模糊搜索（like %xx%）或多条件组合（IN、OR），
需要在每个分片上单独执行，再汇总结果，
对分库分表中间件（如 ShardingSphere、MyCat）来说代价非常高。

而 Elasticsearch 的倒排索引结构天生支持：

- 模糊匹配（wildcard、match、fuzzy）；

- 多字段组合查询；

- 聚合、分页、排序优化；

- 并行查询。

3. 统一查询入口更适合通过 ES 聚合而不是分表路由

分库分表后，查询入口仍需路由逻辑（根据 userId、couponId 等分片键）。
但优惠券查询场景查询条件往往不是唯一键，如：

- 按状态查；

- 按活动名模糊查；

- 按时间区间查；

这些条件无法路由到特定分片，导致全库扫描。

4. 缓存命中率问题

分库分表会进一步降低缓存命中率，因为同一个逻辑查询可能落到不同库表上。
而用 ES 做统一查询层，数据可以做结构化索引 + 聚合缓存，
提高整体缓存命中率。

为什么选ES
| 维度      | Elasticsearch 优势                            |
| ------- | ------------------------------------------- |
| 查询性能    | 倒排索引 + 多字段并行检索 + 分布式架构，查询复杂度远低于分库分表的 SQL 聚合 |
| 模糊与灵活检索 | 原生支持模糊匹配、全文搜索、拼音分词、聚合统计等                    |
| 统一查询服务  | 作为统一查询层聚合多源数据（DB、缓存、异构系统），对上层提供标准化接口        |

### 2.用视图可以解决问题吗

视图是一个“虚拟表”，是基于 SQL 查询结果动态生成的逻辑表。

它本身不存储数据，而是保存一条 SQL 查询语句。

当你查询视图时，MySQL 会在内部把它展开为原始 SQL 再执行。

### 3. ElasticSearch中的Nested数据类型
ElasticSearch中可以将数据以对象的方式存储并查询，但是ES底层的Lucene 没有内部对象的概念，因此如果通过默认的方式往ES中插入对象，ES会将对象层次结构扁平化为字段名称和值的简单列表。 比如下面这一段数据：
``` json
PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [ 
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}
```

如果执行查询
``` json
GET my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "John" }},
        { "match": { "user.last":  "White" }}
      ]
    }
  }
}
``` 

会把这个文档给查出来

这个时候就需要用到nested，nested类型是object数据类型的特殊版本，它允许对象数组以一种可以相互独立查询的方式进行索引。

在Nested内部，每个对象索引其实是一个单独的隐藏文档，这意味着每个嵌套对象都可以独立于其他对象进行查询。

### 3. 查询时延
一个MQ的消息结构如下所示：
``` json
{
    "__opcode__": "UPDATE",
    "__offset__": "228297931",
    "__after_data__":
    "__dataSourceTag__": "jdbc:mysql://11.183.24.69:3306/coupon",
    "__before_data__": 
    "__schemaName__": "coupon.coupon_card"
}
```
大概在3500-4000个字符之间，那么算下来就是3.5kb-4kb之间，如果经过压缩会更低

实际的MQ消费性能

| 配置              | 吞吐量（消费速度）          | 延迟    |
| --------------- | ------------------ | ----- |
| 单 Consumer（单线程） | 5~10 万条/秒（取决于消息大小） | 几毫秒级  |
| 单机多线程（8核16G）    | 50~100 万条/秒        | <10ms |
| 集群扩展后           | 每加一台机器，线性扩展消费能力    |       |

一台 8 核 16G 的机器，在网络和磁盘正常的情况下，可以轻松消费 50 万条/秒以上的消息。

### 4. ES分布式架构的原理是什么

Elasticsearch 本质上是一个 分布式搜索与分析引擎，底层基于 Lucene。
它通过 分片（Shard）+ 副本（Replica） 的机制，将数据分布在多台机器上，实现：

核心组件和职责：

| 角色                           | 职责                                    |
| ---------------------------- | ------------------------------------- |
| **Node（节点）**                 | ES 集群中的一个运行实例（相当于一台机器/一个 JVM 进程）      |
| **Cluster（集群）**              | 由多个 Node 组成的逻辑整体，共享同一个 `cluster.name` |
| **Index（索引）**                | 类似数据库中的表，一个索引可以有多个分片                  |
| **Shard（主分片 Primary Shard）** | 一个 Lucene 实例，保存部分数据                   |
| **Replica Shard（副本分片）**      | 主分片的副本，提供高可用与读扩展                      |

Elasticsearch 的分布式架构基于分片（shard）和副本（replica）机制，所有数据分布在多个节点上。
通过主节点负责集群状态管理、协调节点进行请求路由、分片并行执行查询或写入，从而实现了高可用、高并发、水平扩展的搜索服务。

### 5. ES的index是什么
Index（索引） 是 Elasticsearch 中存储和组织文档（Document）的逻辑集合，相当于关系型数据库中的「表（Table）」。

与MySQL相比，可以做如下类比：
| 概念  | MySQL    | Elasticsearch |
| --- | -------- | ------------- |
| 数据库 | Database | Cluster       |
| 表   | Table    | Index         |
| 行   | Row      | Document      |
| 列   | Column   | Field         |

### 6. ES做分表
冷热分离，通过template匹配

### 7. ES做分页
1. 最基本的分页方式 from+size

这是最常见的分页写法，类似于 SQL 的 LIMIT offset, size
``` json
GET /coupon_index/_search
{
  "from": 0,
  "size": 10,
  "query": {
    "match": {
      "coupon_name": "免息"
    }
  }
}
```

优点：

- 简单直观；

- 适合小页查询（比如前几页）。

缺点：

- 当页码很大时（比如 from=10000），性能急剧下降；

- 因为 ES 必须先取出前面的所有文档再丢弃前 N 条；

- 这是由于 ES 的底层 Lucene 不支持直接跳页，必须顺序扫描。

2. 优化分页方式1：search_after

它利用了 上一次分页结果的排序值，实现基于游标的翻页。

```json
GET /coupon_index/_search
{
  "size": 10,
  "sort": [
    { "create_time": "desc" },
    { "id": "desc" }
  ],
  "search_after": ["2025-05-26T17:18:20", 7410]
}
```
✅ 优点：

不需要重新扫描前 N 条；

分页性能稳定；

适合顺序遍历型查询（如日志、时间序列、滚动加载）。

⚠️ 限制：

必须指定唯一、稳定的排序字段；

不能随机跳页（只能“下一页”方式）；

不支持聚合场景分页。

3. 优化分页方式 2：scroll（滚动查询）

scroll 是为大批量导出数据设计的，不是真分页。

✅ 优点：

能稳定导出上百万数据；

每次游标查询不会重新计算排序。

⚠️ 缺点：

scroll 会在 ES 内部保持上下文（占内存）；

不适合在线分页或用户交互；

查询期间，数据快照是“静态的”，不会看到新增数据。

4. 优化分页方式 3：point in time (PIT)（ES 7.10+）

PIT 是 scroll 的现代替代方案，它更轻量，支持与 search_after 结合。

先创建一个pit，然后查询时使用：

``` json
GET /_search
{
  "size": 10,
  "pit": {
    "id": "46ToAwMDa2l...",
    "keep_alive": "1m"
  },
  "sort": [
    {"create_time": "desc"},
    {"_shard_doc": "desc"}
  ]
}

```

✅ 优点：

一致性好，不会受新增文档影响；

支持长时间分页；

不会占用大量集群内存；

推荐在新版 ES 使用。

性能对比：
| 方式                   | 适用场景     | 性能 | 是否支持跳页 | 一致性   |
| -------------------- | -------- | -- | ------ | ----- |
| `from + size`        | 小页（前几页）  | 中  | ✅      | ❌     |
| `search_after`       | 深分页、时间序列 | 高  | ❌      | ✅     |
| `scroll`             | 大批量导出    | 高  | ❌      | ✅（快照） |
| `PIT + search_after` | 实时滚动分页   | 高  | ❌      | ✅✅    |

### 8. 进程，线程，协程
略

### 9. 哈希表如何解决冲突

### 10. 为什么B+树比B树更加适合做索引

| 特性   | B 树            | B+ 树                              |
| ---- | -------------- | --------------------------------- |
| 查询效率 | 内部节点也有数据，可直接找到 | 查询都走叶子节点，叶子节点连续，磁盘 IO 少           |
| 范围查询 | 不方便，可能需要多次回溯   | 叶子链表顺序遍历即可，非常快                    |
| 节点存储 | 键+数据           | 内部节点只存键 → 每个节点可存更多键 → 树更矮 → IO 更少 |
| 磁盘友好 | 一般             | 更适合磁盘存储和 SSD/B+树索引                |


自我追问：为啥不用跳表

跳表是基于链表的多层索引，节点存储在内存中，随机访问成本低。

每次查找需要频繁访问指针（CPU 内存访问），如果放在磁盘上：

- 每个指针可能对应不同磁盘页（页大小一般 16KB）

- 磁盘访问是顺序读取更快，随机访问开销大

B+ 树高度扁平、每个节点存大量键，一次 IO 读一个节点，能覆盖多条记录，磁盘访问效率更高。

### 11. 如何设计高并发，低延迟的服务
高并发低延迟服务设计核心是 解耦异步、缓存降级、分布式扩展、IO 非阻塞和数据库优化。通过消息队列削峰、缓存减少 DB 压力、B+ 树索引优化查询、连接池和异步 IO 提升吞吐，同时监控和限流保证系统稳定。

### 12. 如何改进接口
略

### 13. 手撕1：合并两个升序数组

### 14. 手撕2：完全背包问题
