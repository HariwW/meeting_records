### 后端开发-得物
1、详细介绍查询接口的性能提升情况

“我们系统需要给不同商户推荐不同产品，每个产品有多套展示配置，计算量很大，比如 6 个产品 × 36 套配置。顺序计算接口响应慢，大约 1500ms。为了解决这个问题，我做了两方面优化：一是用 Redis 缓存规则，避免频繁访问数据库，并提供开关支持紧急修改；二是用 CompletableFuture + 自定义线程池将每个产品的规则计算异步并行执行。经过优化后，接口响应从 1500ms 降到 400ms，性能提升了接近 4 倍，同时保持规则的动态可控性。”

2、优惠券的数据模型

答：回答时可以按 ids(三个id)，types(优惠券type，业务type)，优惠券自身信息（发放时间，锁定状态，使用时间等），还有持券人的信息

3、券信息和流水信息是否耦合

答：我们目前的模型是耦合设计，把券的基本信息、发放信息、持有人信息和使用流水放在同一份文档里，这样能减少查询成本、支撑高 QPS。但它的代价是扩展性差，如果未来需要支持多次使用或更复杂的流水审计，我们会考虑将 usage_log 单独拆表，做成解耦设计。

4、接口的QPS？

答：平时在100-200之间，在大促期间会到500-800之间

5、为什么要用装饰器模式

答：最底层是基础服务，负责核心推荐功能；在基础服务上，通过装饰器动态叠加增强功能，例如主位副位判断、素材变量替换等。装饰器链可以灵活组合，不同商户或产品的定制逻辑通过链上的不同装饰器实现，无需修改基础类。为了统一创建不同链的实例，我们用工厂模式管理代理类和装饰器链的生成。

6、CompletableFuture和普通的Future有什么区别

Future 只能表示异步任务结果，get() 会阻塞，而且组合多个任务麻烦；而 CompletableFuture 支持非阻塞回调、链式组合和异步异常处理，更适合复杂异步场景，比如同时计算多产品多配置规则的推荐逻辑
“我们没有用普通的 Future，主要有三个原因：

1️⃣ 阻塞问题：普通 Future 调用 get() 会阻塞线程，处理大量规则时容易导致线程占用过多，响应慢；而 CompletableFuture 支持非阻塞回调，可以在任务完成后自动处理结果，不影响主线程。

2️⃣ 任务组合能力：我们的规则计算涉及多个产品、多套配置，需要同时并行计算并汇总结果。Future 很难方便地组合多个任务，而 CompletableFuture 提供链式组合和 allOf / anyOf 聚合方法，方便管理多个异步任务。

3️⃣ 异常和灵活性：CompletableFuture 支持链式异常处理和自定义线程池，保证异步任务稳定执行，也方便扩展新的规则逻辑，而普通 Future 异常只能在阻塞时捕获，灵活性较差。

所以在高并发和复杂异步场景下，CompletableFuture 更适合我们业务需求。”

7、为什么要用MQ
1️⃣ 直接监听 Binlog 的问题

直接消费 Binlog：应用直接解析数据库变更日志（例如通过 Canal）

问题：

耦合强：业务服务直接依赖数据库 Binlog，数据库压力大或变动会影响业务。

可靠性差：一旦消费失败或服务宕机，可能丢失数据，需要额外实现补偿机制。

扩展性差：多个业务服务都需要监听同一 Binlog，难以横向扩展。

高并发处理复杂：直接消费 Binlog 时，顺序、事务和并发控制都需要自己处理。

2️⃣ 使用 MQ 的优势

解耦：生产者（DTS 或 Binlog 推送服务）与消费者（业务处理服务）解耦，服务可以独立扩展和部署。

可靠性：MQ 支持消息持久化、重试机制和消费确认，保证消息不丢失。

高并发和异步：MQ 能够平滑处理高 QPS，消费者可按业务类型并行消费。

灵活路由：不同业务可以注册不同消费者，按策略模式处理消息，实现多业务共存。

可扩展性：新业务或新功能只需增加新的消费者，不影响原有流程。

我们不直接监听 Binlog，而是通过 MQ 同步增量数据。原因是：直接消费 Binlog 会耦合业务和数据库，处理高并发和异常补偿复杂。而 MQ 提供可靠的消息持久化、异步消费和多业务分发能力，既保证了数据可靠性，也方便我们按业务类型灵活扩展和处理

8、如何设计发券系统

发券
1）触发条件”用户注册、下单、参与活动或运营后台手动发放。

2）策略判断：判断用户是否符合条件（等级、历史消费、活动次数等）。判断券是否还有剩余库存。

3）券生成/领取：系统生成或从已有券池中分配一张券给用户。写入 UserCoupon 表，记录用户ID、券ID、发放时间、状态（未使用）。

4）缓存与消息：更新券库存缓存（如 Redis）。发送消息到 MQ，通知用户或其他系统更新状态。

5）发放完成：用户收到券，可在个人中心查看。

核销：

1）用户使用券：用户在下单/支付时选择使用优惠券。

2）券验证

检查券状态：否未使用

是否在有效期内：是否满足使用条件（如最低消费），可通过 Redis 缓存快速校验。

3）核销操作：扣减券库存（原子操作）更新 UserCoupon.status = 已使用，记录 used_time 和 order_id

4）事务保证：核销与订单支付保持事务一致性，防止重复核销或丢失券。

5）异步统计：核销完成后，异步更新券使用统计信息和报表。

9、Spring Nacos和Zookeeper的区别
Nacos 是“注册中心 + 配置中心一体化”，Zookeeper 更偏向分布式协调工具。

10、Spring启动流程

Spring 启动大致分为 加载、创建容器、注册 Bean、初始化、完成 五大阶段

初始化 SpringApplication：读取主类、加载环境配置（application.yml/properties）、确定运行模式（普通应用或 Web 应用），并准备 SpringApplication 对象。

创建 ApplicationContext：根据应用类型创建相应的容器（如 AnnotationConfigApplicationContext 或 AnnotationConfigServletWebServerApplicationContext），并注册核心 Bean，如环境变量、事件广播器和消息源。

扫描和注册 Bean：扫描 @Configuration、@Component、@Service、@Repository、@Controller 等注解类，将 BeanDefinition 注册到容器，同时解析依赖注入相关注解（@Autowired、@Value）。

Bean 实例化与初始化：按照依赖关系实例化 Bean，执行 Aware 接口方法（如 ApplicationContextAware）、初始化回调（@PostConstruct、afterPropertiesSet()），并执行 BeanPostProcessor 的前后处理方法。

刷新容器与事件发布：刷新容器完成单例 Bean 初始化，并发布相关事件（如 ContextRefreshedEvent、ApplicationReadyEvent）通知应用已准备就绪。

WebServer 启动与回调执行（Spring Boot）：如果是 Web 应用，启动内置 WebServer（Tomcat/Jetty/Undertow），注册 DispatcherServlet，并执行 CommandLineRunner 或 ApplicationRunner 等启动回调。

11、Spring IOC

Spring IOC（控制反转）是 Spring 框架提供的一种设计思想和容器机制，它通过容器来创建对象、管理对象的生命周期和注入对象之间的依赖，从而实现了对象之间的解耦。Spring IOC 的核心是 BeanFactory 或 ApplicationContext，它通过 BeanDefinition 和依赖注入（DI）机制，将对象依赖交给容器管理，而不是让对象自己去创建和管理依赖。