### 问题1：JMM介绍下
Java 内存模型（JMM）定义了多线程环境下 线程与主内存的交互规则。

它规定了变量的可见性、原子性和有序性：

原子性：保证基本操作不可分割；

可见性：一个线程修改变量，其他线程能及时看到（通过 volatile、锁、final 保证）；

有序性：禁止指令重排序对多线程语义的破坏（通过 volatile、synchronized、Lock 保证）。

本质上，JMM 是一种抽象规范，屏蔽了底层硬件和编译器的优化差异。

### 问题2：gc算法介绍下
Java 的 GC（垃圾回收器）是 JVM 用来自动管理堆内存的机制，主要做两件事：

发现垃圾（不再被引用的对象）；

回收内存，供新对象分配。

核心算法包括：引用计数（基本不用）、标记-清除、复制、标记-整理、分代收集。
JVM 提供多种垃圾回收器（如 Serial、Parallel、CMS、G1、ZGC、Shenandoah），根据场景选择合适的 GC 策略。

如何判断对象是否存活

引用计数法：实现简单，但难以解决循环引用（Java 基本不用）。

可达性分析（Reachability Analysis）：通过 GC Roots（如栈中的引用、静态变量、JNI 引用）向下遍历，对象不可达即为垃圾。

常见算法

标记-清除（Mark-Sweep）：标记存活对象，清理垃圾；缺点是碎片化。

复制（Copying）：把存活对象复制到另一块区域，适用于新生代；优点是高效，缺点是浪费空间。

标记-整理（Mark-Compact）：在标记清除基础上整理内存，适用于老年代。

分代收集：新生代用复制算法，老年代用标记整理，提升性能。

主流垃圾收集器

Serial：单线程，适合单核、小内存环境。

Parallel（吞吐量优先）：多线程收集，适合后台任务。

CMS（低延迟）：并发收集，减少停顿时间，但会产生碎片。

G1（均衡）：分区收集，支持大堆，延迟和吞吐均衡。

ZGC / Shenandoah：低延迟收集器，停顿时间可控制在毫秒级。

### 问题3：为什么年轻代使用复制算法进行gc，老年代使用标记算法进行gc
Java 分代收集的核心理念是 “大部分对象很快死掉，少部分对象长时间存活”，所以采用不同算法优化性能：

年轻代（Young Generation）

对象大多短命（如方法内部临时对象），存活率低。

复制算法（Copying）：

将存活对象从 Eden 区复制到 Survivor 区或另一个 Survivor 区。

优点：操作快、整理内存（无碎片）、分配简单（只需要一个指针 bump pointer）。

缺点：浪费一半空间（两个 Survivor 区），但年轻代本来就小，所以可接受。

老年代（Old Generation）

对象长时间存活，存活率高（大对象、缓存等）。

标记-清理 / 标记-整理算法（Mark-Sweep / Mark-Compact）：

标记存活对象，清理垃圾；标记-整理还能压缩内存，避免碎片。

优点：不需要复制大量存活对象，节省 CPU 和内存带宽。

缺点：相对慢，但老年代 GC 发生频率低，可接受。

总结：年轻代使用复制算法：因为大多数对象都是朝生暮死的，存活率低。复制算法把存活对象从一个半区复制到另一半区，效率高，且自动整理空间，避免碎片化。
老年代使用标记-清理或标记-整理：老年代对象存活时间长，存活率高，复制大量对象代价大。标记-整理算法可在原地回收垃圾，节省内存开销，但相对慢一些。


### 问题4：复制算法的特点
复制算法扫描存活对象并将其复制到新区域，速度快、内存连续、碎片少，非常适合对象生命周期短的新生代

### 问题5：为什么不在年轻代使用标记-整理，标记-复制算法呢
新生代对象生命周期短、存活率低。

标记-清除 / 标记-整理需要扫描整个区域或移动大量对象，效率较低。

复制算法只处理存活对象、自动整理内存、分配速度快，正好适合年轻代。

### 问题6：为什么不在老年代使用复制算法：
老年代对象存活率高，很多对象长时间存在。

复制算法需要复制所有存活对象，如果存活对象多，开销很大。

标记-清除 / 标记-整理算法更适合老年代，节省内存和 CPU 成本。

### 问题7：java保证多线程安全的
“Java 提供关键字（synchronized、volatile）、锁与同步工具（ReentrantLock、ReadWriteLock、Semaphore 等）、线程安全集合（ConcurrentHashMap、BlockingQueue）、线程池与异步任务管理（Executor、Callable/Future）、原子类（AtomicInteger/AtomicReference）以及线程通信方法（wait/notify、Lock+Condition、join）等多种手段来简化多线程并发编程，保证原子性、可见性和高效性。”

### 问题8：介绍下TCP的可靠传输和拥塞控制
TCP 通过序列号、确认应答、滑动窗口、超时重传和校验和机制，实现可靠的数据传输。

TCP 拥塞控制通过慢启动、拥塞避免、快重传和快恢复机制动态调整发送速率，防止网络拥塞，同时保证数据可靠传输

### 问题9：索引失效的场景，如何设计索引
1. 索引列参与运算或函数

例子：WHERE YEAR(create_time) = 2023

原因：索引列被函数包裹，索引无法直接使用。

2. 前缀模糊匹配

例子：WHERE name LIKE '%abc'

原因：索引只能从开头匹配，前置 % 会导致全表扫描。

3. 数据类型不匹配

例子：WHERE id = '123'（id 是 int）

原因：隐式类型转换会导致索引失效。

4. OR 条件导致

例子：WHERE a = 1 OR b = 2

如果 a 和 b 都有单列索引，通常会导致索引失效，除非使用 联合索引。

5. 范围查询后的列

例子：WHERE a = 1 AND b > 10 AND c = 5

如果索引是 (a,b,c)，b > 10 是范围查询，之后的 c 列索引无法使用。

6. 使用 NOT / <> / IS NULL 等操作

例子：WHERE a <> 1 或 WHERE a IS NULL

原因：这些条件通常不能利用索引排序特性，导致全表扫描。

7. ORDER BY / GROUP BY 不匹配索引

如果排序列或分组列与索引顺序不一致，索引可能失效，需要额外排序。

8. 联合索引最左前缀原则未遵循

例子：索引 (a,b)，查询条件只写 b=...，索引无法使用。

设计索引时：

1. 选择高选择性列作为索引

选择 不同值多、重复值少 的列

如身份证号、手机号、订单号等

2. 列顺序优化（复合索引）

常用条件列放在前，范围查询列放在后

避免导致后续列索引失效

3. 覆盖索引（索引包含列）

让查询只访问索引即可满足 SELECT，减少回表

SQL 示例：

CREATE INDEX idx_user_name_age ON user(name, age);
SELECT name, age FROM user WHERE name='zhang';


4. 避免不必要的索引

索引会增加写入、删除、更新成本

建立必要索引，避免冗余

5. 考虑查询模式

优先分析 WHERE、JOIN、ORDER BY、GROUP BY 条件

针对高频查询列建立索引

6. 结合业务设计

对历史数据、冷数据可以选择 分区表 + 索引

对热数据，保证索引选择性高

### 问题10：redis中内存驱逐的策略
当 Redis 设置了 maxmemory 限制且内存使用达到上限时，需要 驱逐（淘汰）部分数据以释放空间。

Redis 提供了 多种内存淘汰策略（eviction policies），可通过 maxmemory-policy 配置。

Redis 内存驱逐策略用于在 maxmemory 限制下释放空间，常用策略包括 LRU、LFU、TTL 或随机淘汰，可针对所有 key 或仅带过期时间的 key。策略选择应结合业务场景，如热点缓存推荐 allkeys-lru，过期数据优先 volatile-ttl    


### 问题11：装饰器模式和代理模式的区别
装饰器模式：动态给对象 增加功能，不改变原对象接口或结构，可以 多层装饰，动态叠加功能

代理模式（Proxy）为对象提供 代理访问，控制对真实对象的访问或增强行为，可以 多层装饰，动态叠加功能

适配器模式：“适配器模式用于将一个类的接口转换成客户期望的接口，使不兼容的类可以协同工作。它只改变接口，不改变原对象功能。对象适配器通过组合实现，类适配器通过继承实现。

设计一个内存管理器，要求时间复杂度为O(1)，用哪些数据结构，要有malloc函数，关注两点：1、用什么数据结构 2、虚拟块用什么形式组织

为了 O(1) 分配和回收，我们可以使用：1、空闲链表，每个大小类维护一个